import createFilename from "../helpers/createFilename.js";
import ClickupService from "../services/clickupService.js";
import GCPStorageService from "../services/gcpStorageService.js";
import GeminiService from "../services/geminiService.js";
import { logger } from "@oisamitech/sami-logger";

export default class TicketController {
    constructor(fastify) {
        this.fastify = fastify;
        this.clickupService = new ClickupService();
        this.geminiService = new GeminiService();
        this.gcpStorageService = new GCPStorageService();
    }

    async categorizeTicket(request, reply) {
        try {
            const { task_id, history_items = [] } = request.body;
            
            let isFromOurAPI = history_items.some(item => 
                item.user && item.user.id === parseInt(process.env.CLICKUP_USER_ID)
            );
            
            if (isFromOurAPI) {
                return reply.code(200).send({ success: true, message: 'Event from own API ignored' });
            }
            
            if (!history_items.some(item => item.user)) {
                return reply.code(422).send({ success: false, message: 'event not generated by a user' });
            }
            
            let cacheKey = `ticket_${task_id}`;
            if (this.fastify.redis && await this.fastify.redis.has(cacheKey)) {
                return reply.code(200).send({ success: true, message: 'ticket already processed recently' });
            }
            
            // Resposta imediata para o webhook
            reply.code(202).send({ success: true, message: 'Processing...' });
            
            // Processamento assíncrono
            this.processTicketAsync(task_id, cacheKey).catch(error => {
                logger.error('Async processing error:', error);
            });
            
        } catch (error) {
            logger.error('Error processing webhook:', {
                error: error.message,
                task_id: request.body.task_id,
                timestamp: new Date().toISOString()
            });
            
            return reply.code(500).send({ 
                success: false, 
                message: 'Error processing webhook', 
                error: error.message 
            });
        }
    }

    async processTicketAsync(task_id, cacheKey) {
        try {
            if (this.fastify.redis) {
                await this.fastify.redis.set(cacheKey, true, 300000);
            }
            
            const ticket = await this.clickupService.getTicket(task_id);
            
           const isAlreadyProcessed = ticket.priority || (ticket.tags && ticket.tags.length > 0) || ticket.squad || ticket.origin;
            
            if (isAlreadyProcessed) {
                logger.info(`Ticket already categorized: ${task_id}`);
                return;
            }
            
            let files = null;
            if (this.fastify.redis) {
                files = await this.fastify.redis.getFiles();
            }
            
            if (!files) {
                files = await this.gcpStorageService.getAllFiles();
                if (this.fastify.redis) {
                    await this.fastify.redis.saveFiles(files);
                }
            }

            const categorization = await this.geminiService.categorizeTicket(ticket, files);
            
            if (!categorization) {
                logger.warn(`⚠️ Could not categorize ticket: ${task_id}`);
                return;
            }
            
            logger.info('Categorization:', categorization);
            
            if (categorization.priority) {
                await this.clickupService.setPriority(task_id, { 
                    priority: categorization.priority 
                });
                logger.info('✅ Priority updated:', {
                    task_id,
                    priority: categorization.priority
                });
            }
            
            if (categorization.tags?.[0]?.name) {
                await this.clickupService.addTagToTicket(
                    task_id, 
                    categorization.tags[0].name
                );
                logger.info('✅ Tag added:', {
                    task_id,
                    tag: categorization.tags[0].name
                });
            }

            if (categorization.squad) {
                await this.clickupService.setCustomField(
                    task_id,
                    categorization.squad.field_id,
                    categorization.squad.value,
                    "Squad"
                );
                logger.info('✅ Squad updated:', {
                    task_id,
                    squad: categorization.squad.option.name
                });
            }

            if (categorization.origin) {
                await this.clickupService.setCustomField(
                    task_id,
                    categorization.origin.field_id,
                    categorization.origin.value,
                    "Origem"
                );
                logger.info('✅ Origin updated:', {
                    task_id,
                    origin: categorization.origin.option.name
                });
            }

            if (categorization.product) {
                await this.clickupService.setCustomField(
                    task_id,
                    categorization.product.field_id,
                    categorization.product.value,
                    "Produto"
                );
                logger.info('✅ Product updated:', {
                    task_id,
                    product: categorization.product.option.name
                });
            }
        } catch (error) {
            logger.error('Error in async processing:', {
                error: error.message,
                task_id,
                timestamp: new Date().toISOString()
            });
        }
    }

    async saveTickets(request, reply) {
        try {
            const { id } = request.body;

            let tasks = await this.clickupService.getTickets(id);
            let list = await this.clickupService.getList(id);
    
            let filename = createFilename(list.name, 'json');
            let uploadResult = await this.gcpStorageService.uploadFile(tasks, filename);
            
            // Calculate statistics
            const totalTasks = tasks.length;
            const tasksWithTags = tasks.filter(task => task.tags && task.tags.length > 0).length;
            const tasksWithoutTags = totalTasks - tasksWithTags;
            
            return reply.code(200).send({
                success: true,
                message: 'File uploaded to GCP Storage successfully!',
                data: {
                    list: {
                        id: id,
                        name: list?.name || 'Name not available',
                        totalTasks: totalTasks
                    },
                    file: {
                        filename: filename,
                        bucket: process.env.GOOGLE_CLOUD_BUCKET_NAME,
                        gcpPath: `${filename}`,
                        size: `${JSON.stringify(tasks).length} bytes`,
                        uploadResult: uploadResult
                    },
                    statistics: {
                        totalTasks: totalTasks,
                        tasksWithTags: tasksWithTags,
                        tasksWithoutTags: tasksWithoutTags
                    },
                    processingTime: new Date().toISOString()
                }
            });

        } catch (error) {
            logger.error(`Processing error:`, error.message);
            
            return reply.code(500).send({ 
                success: false,
                message: 'Error processing and saving tasks',
                error: error.message,
                timestamp: new Date().toISOString()
            });
        }
    }

    async health(request, reply) {
        const uptime = process.uptime();
        return reply.code(200).send({ 
            success: true, 
            message: 'Webhook is running',
            uptime: Math.floor(uptime),
            timestamp: new Date().toISOString()
        });
    }
}